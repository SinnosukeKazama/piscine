ft_print_memory
＜流れ＞

入力された文字列を整数型にして、16進数表記文字列にする。
文字列の先頭アドレスと、そこから16文字ごとのアドレスを文字列にする。（空白は'.'に）

char型からint型にして16進数の文字列にする。ヌル文字まで。

繰り返し
 	|アドレス出力
 	|16進数表記の文字列出力： 
 	|文字列出力
 	|改行

＜必要な関数＞
64bit符号なし整数型(addrssが64bitでそれに対応するため） を 文字列 にする関数 (void itoa(char* dest, unsigned long n, int radix))
|文字列を整数型にして、16進数表記文字列にする関数( void str_to_num(int* hex_str, int* str, ) )
|	char型からint型にして16進数の文字列にする。
|文字列の先頭アドレスと、そこから16文字ごとのアドレスを文字列にする関数( void ul_to_hex(int* str, unsigned long ul))
|	ポインタ型とunsigned int型が８バイト.
|

１６ごとにアドレスを渡す関数
|アドレス文字列を出力する関数 void out_addr(char* addr)
	アドレス（unsigned int）を 16進数文字列にする'呼出(itoa)
	規定文字数 ー アドレス文字数 ＝ ０の数”出力
	アドレス”出力（itoaの仕様で文字列が逆になっていることに注意）

|16進数文字列を出力する関数 void out_hex(char* addr)
	文字列を数字の列にして、
	数字の列を16進数文字にする’呼出 (itoa)

	１６文字の文字列を16進数にした文字数 ＝ 16*2=32 。。違う
	文字数 ＝ 16
	16文字の中で空白の数、2文字毎 ＝16/2=8
	合計文字数 ＝文字数＋空白数 ＝２４
	_______合計文字数に満たない場合、空白を入れる

|文字列を１６ずつ出力する関数 void out_str(char* addr)


＜必要な変数＞
文字列：char*
１６進数文字列：char*
アドレス：int*
アドレス文字列:char*




----------------------------------------------------------------------
基数変換
割れるまで
|num % radix = mod
|mod % radix =mod2
|mod2 % radix = mod3

m3 m2 m